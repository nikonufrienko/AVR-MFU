/*
 * snake.h
 *
 * Created: 22.10.2019 15:38:00
 *  Author: Admin
 */ 


#ifndef SNAKE_H_
#define SNAKE_H_
#ifndef _UTIL_DELAY_H_
#include <util/delay.h>
#endif
#ifndef KEYS
#define UP_BUT PD3
#define DOWN_BUT PD7
#define LEFT_BUT PB0
#define RIGHT_BUT PD6
#define SELECT1_BUT PD2
#define SELECT2_BUT PD5
#define SPK PB1
#define SPK_PORT PORTB
#endif
#include <stdlib.h>//нужно для генерации случайных чисел
const byte start [] = {
	0x00, 0xFE, 0x20, 0x10, 0xFE, 0x00, 0xFC, 0x04, 0x04, 0x00, 0xFC, 0x24, 0x18, 0x00, 0xF8, 0x24,
	0xF8, 0x00, 0x04, 0xFC, 0x04, 0x00, 0xFC, 0xA0, 0x40,0x00
};
const unsigned char sl [] = {
	0x00, 0x3C, 0x42, 0x42, 0x00, 0x60, 0x1E, 0x02, 0x7E, 0x00, 0x3C, 0x42, 0x3C, 0x00, 0x66, 0x18,
	0x7E, 0x18, 0x66, 0x00, 0x7E, 0x10, 0x7E, 0x00, 0x3C, 0x42, 0x3C, 0x00, 0x3C, 0x42, 0x42, 0x00,
	0x02, 0x7E, 0x02, 0x00, 0x7E, 0x50, 0x20, 0x00,
};
const unsigned char logo [] = {
	0x00, 0x00, 0x00, 0x80, 0xE0, 0xF0, 0x18, 0x88, 0x80, 0x80, 0x00, 0xF0, 0xE0, 0xC0, 0x00, 0x00,
	0x00, 0xF0, 0xE0, 0x00, 0xC0, 0xF0, 0xF0, 0x80, 0x00, 0x18, 0xF8, 0xF0, 0xC0, 0x60, 0x30, 0x00,
	0x00, 0x18, 0xF8, 0xF0, 0x30, 0x10, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0xC0, 0x40, 0x40, 0xC0, 0xC0, 0x60,
	0x20, 0x20, 0x60, 0xC0, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x1E, 0x00, 0x10, 0x00,
	0x1E, 0x12, 0x1E, 0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x83, 0xE3, 0x31, 0x1F, 0x0F, 0x00, 0xFF,
	0x7F, 0x01, 0x07, 0x3C, 0x7E, 0x0F, 0xC1, 0xF8, 0x1F, 0x19, 0x19, 0x1F, 0xFE, 0xC0, 0x1F, 0xFF,
	0x66, 0x06, 0x0E, 0x1C, 0x18, 0x30, 0x01, 0xFF, 0xFE, 0x86, 0x83, 0x83, 0x83, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x38, 0x4E, 0x42, 0x4A, 0x82, 0x86, 0x84, 0x84, 0x04, 0x04, 0x07, 0x0C, 0x0B,
	0x8B, 0x89, 0xCF, 0x48, 0x6B, 0x0B, 0x08, 0x8A, 0xEB, 0xEE, 0x76, 0x1C, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0xC0,
	0x60, 0x20, 0x30, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x10, 0x30, 0x20, 0x20, 0x60, 0x40, 0xC0,
	0x80, 0x03, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x09, 0x19,
	0x39, 0x30, 0xF0, 0xA0, 0x20, 0x60, 0x40, 0xC0, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x11, 0x13,
	0x92, 0x7A, 0x0E, 0x06, 0x03, 0x07, 0x0D, 0x11, 0x31, 0x21, 0x61, 0xC1, 0x81, 0x03, 0x0E, 0x18,
	0x30, 0x60, 0xC0, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0xF0, 0x1E, 0x03, 0x01, 0x00, 0x00, 0x00, 0x80, 0xC0, 0x70, 0x18, 0x08, 0x08, 0x08, 0x18, 0x10,
	0x30, 0x60, 0xC0, 0x00, 0x01, 0x01, 0x01, 0x06, 0x04, 0x08, 0x18, 0x30, 0x60, 0xC0, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x06, 0x1C, 0x30, 0xE1, 0x81, 0x03, 0x02,
	0x04, 0x08, 0x18, 0x30, 0x60, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x01, 0x03, 0x8E, 0xF8, 0x00, 0x00, 0x00, 0x01, 0x07, 0x1C, 0xF0, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0xFF, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x06, 0x1C, 0x70, 0x40,
	0x40, 0x40, 0x60, 0x20, 0x20, 0x20, 0x21, 0x23, 0x26, 0x2C, 0x38, 0x30, 0x30, 0x60, 0x40, 0x40,
	0x40, 0x40, 0x43, 0x46, 0x4E, 0x5C, 0x70, 0x60, 0x40, 0x60, 0x20, 0x20, 0x20, 0x20, 0x20, 0xB0,
	0xD0, 0x71, 0x1F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0xFF, 0x10, 0x10, 0x10, 0x08, 0x08,
	0x08, 0x08, 0x0C, 0x04, 0x06, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0xC0, 0x3C, 0x07, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x07, 0x0C, 0x18, 0x10, 0x30, 0x20, 0x20,
	0x20, 0x60, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x60, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20,
	0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x20, 0x60, 0x60, 0x60, 0x70, 0x50, 0x50, 0x50, 0x58, 0x5C,
	0x46, 0x47, 0x43, 0x41, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x40, 0x60, 0x30, 0x1C, 0x17, 0x18,
	0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x0C, 0x04, 0x04, 0x06, 0x02, 0x02, 0x03, 0x01,
	0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};
const unsigned char scorel [] = {
	0x00, 0x7E, 0x0A, 0x04, 0x00, 0x7C, 0x54, 0x44, 0x00, 0x7C, 0x10, 0x6C, 0x00, 0x38, 0x44, 0x38,
	0x00, 0x7C, 0x14, 0x08, 0x00, 0x60, 0x38, 0x24, 0x3C, 0x60, 0x00,0x22,0x00
};
const unsigned char Gov [] = {
	0x00, 0x00, 0x00, 0x80, 0x40, 0x40, 0x40, 0x40, 0x40, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x3E, 0xC1, 0x80, 0x00, 0x08, 0x08, 0x08, 0x08, 0xF8, 0x00, 0x00,
	0xE4, 0x22, 0x12, 0x12, 0x12, 0x92, 0xFC, 0x00, 0x00, 0xFE, 0x04, 0x02, 0x02, 0x02, 0x06, 0xFC,
	0x04, 0x02, 0x02, 0x02, 0xFC, 0x00, 0x00, 0x78, 0x94, 0x12, 0x12, 0x12, 0x16, 0x9C, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x78, 0x84, 0x02, 0x02, 0x02, 0x02, 0x84, 0x78, 0x00, 0x02, 0x1E, 0xF0,
	0x80, 0x80, 0x70, 0x1E, 0x02, 0x00, 0x78, 0x94, 0x12, 0x12, 0x12, 0x16, 0x9C, 0x00, 0x00, 0xFE,
	0x04, 0x02, 0x02, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01,
	0x01, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x81, 0x01, 0x00, 0x01, 0x00, 0x00, 0x81, 0x00, 0x00,
	0x00, 0x80, 0x00, 0x01, 0x00, 0x00, 0x80, 0x80, 0x01, 0xC0, 0x20, 0x90, 0x90, 0x99, 0x89, 0x09,
	0x09, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0x01, 0x01, 0x01, 0x01, 0x80, 0x80,
	0x80, 0x00, 0x00, 0x00, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01, 0x01, 0x01, 0x01,
	0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x7F, 0x04, 0x04, 0x04, 0x04,
	0x04, 0x7F, 0x00, 0x00, 0x00, 0x03, 0x1E, 0x90, 0xD0, 0x3C, 0x07, 0x00, 0x00, 0x1F, 0x21, 0x40,
	0x40, 0x40, 0x40, 0x21, 0x1E, 0x00, 0x00, 0x39, 0x48, 0x44, 0x44, 0x44, 0x24, 0x7F, 0x00, 0x00,
	0x1E, 0x61, 0x40, 0x40, 0x40, 0x21, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0x03, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};
uint8_t sprites[3][4]={{0x00,0x00,0x00,0x00},{0xff,0xff,0xff,0xff},{0xff,0x99,0x99,0xff}};

uint8_t slozh=1;
const unsigned char num [10][4] ={ {0x00, 0x7C, 0x82, 0x7C}, {0x00, 0x84, 0xFE, 0x80},{0x00, 0xE4, 0x92, 0x8C},{0x00, 0x84, 0x92, 0x6C},{0x00, 0x1E, 0x10, 0xFE},
{0x00, 0x9E, 0x92, 0x62},{0x00, 0x7C, 0x92, 0x64},{0x00, 0x02, 0xF2, 0x0E},{0x00, 0x6C, 0x92, 0x6C},{0x00, 0x4C, 0x92, 0x7C}};
uint16_t keygame=0;
byte dlina=2;//изначальная длина змейки
byte score=0;

void draw_result(uint8_t y,uint8_t x, uint8_t res)
{
	setpos(y,x);
	int buff=1000;
	for(int i=0; i<3; i++)
	{
		for(int z=0;z<4;z++)
		{
			input(num[((res%buff)*10)/buff][z]);
		}
		buff/=10;
	}
}
void draw_logo()
{
	for(int i=0;i<504;i++)
	{
		input(logo[i]);
	}
	_delay_ms(1000);
	clear();
}
void beep()
{
	cli();
	for(int i=0;i<100;i++)
	{
		SPK_PORT|=(1<<SPK);
		_delay_us(500);
		SPK_PORT&=~(1<<SPK);
		_delay_ms(1);
	}
	sei();
}
void shortbeep()
{
	cli();
	for(int i=0;i<250;i++)
	{
		SPK_PORT|=(1<<SPK);
		_delay_us(500);
		SPK_PORT&=~(1<<SPK);
		_delay_us(500);		
	}
	sei();
}
byte pole[16][12];
uint8_t snake[192];
byte vect=0;//вектор движения змейки

byte eeprom_read(uint16_t adr)
{
	while(EECR & (1<<EEPE));//ждем конца записи
	EEAR=adr;
	EECR |= (1<<EERE);
	//while(EECR&(1<<EERE));//ждем конца чтения
	return EEDR;
}
void eeprom_write(uint16_t adr, byte value)
{
	while(EECR & (1<<EEPE));
	EEAR=adr;
	EEDR=value;
	EECR|=(1<<EEMPE);
	EECR|=(1<<EEPE);
	while(EECR & (1<<EEPE));
}
byte eeprom_read_score()
{
	if(eeprom_read(0)!=0x0f)
	{
		return 0;	
	}
	else
	{
		return eeprom_read(1);
	}
}
void eeprom_write_score(uint8_t value)
{
	if(score<value)
	{
		eeprom_write(0,0x0f);
		eeprom_write(1,value);
	}
}

void clearpole()
{
	for(int y=0;y<12;y++)
	{
		for(int x=0;x<16;x++)
		pole[x][y]=0x00;
	}
}

void drawpole()
{
	setpos(0,0);
	for(int y =0; y<6;y++)
	{
		setpos(y,0);
		for(int x = 0; x <16;x++)
		{
			for(int j=0;j<4;j++)
			{
				input((sprites[pole[x][(y*2)]][j] >>4)|(sprites[pole[x][(y*2)+1]][j]<<4));
			}
		}
		
	}
}
void draw_gran()
{
	for(int y =0;y<6;y++)
	{
		setpos(y, 64);
		input(0xff);
	}
	setpos(0,0);
}
void snake_step()
{
	uint8_t x = snake[0]>>4;
	uint8_t y = snake[0]&0x0f;
	switch (vect)
	{
		case 0: if(y>0)
		y-=1;
		else
		y=11;
		break;
		case 1: y+=1; break;
		case 2: if(x>0)
		x-=1;
		else
		x=15;
		break;
		case 3: x+=1; break;
	}
	uint8_t buff = snake[1];
	snake[1]=snake[0];
	snake[0]= (((x)&0x0f)<<4)|(y%12);
	for(uint8_t i=1;i<dlina-1;i++)
	{
		uint8_t bf2 = buff;
		buff = snake[i+1];
		snake[i+1]=bf2;
		
	}
	
}
void draw_snake_to_pole()
{
	for(uint8_t i = 0;i<dlina;i++)
	{
		pole[snake[i]>>4][snake[i]&0x0f]=0x01;
	}
}
byte apleIsEated=1;
uint8_t aplemaincord=0x00;
void draw_aple_to_pole()
{
	pole[aplemaincord>>4][aplemaincord&0x0f]=0x02;
}
byte IsThisEatable(byte snakex, byte snakey,byte aplex,byte apley)
{

	switch(vect)
	{
		case 0://змейка идёт вверх
		if((snakex == aplex)&&((apley==(snakey-1))||((snakey==0)&&(apley==11))))
		{
			return 1;
		}
		break;
		case 1://змека идёт вниз
		if((snakex == aplex)&&((apley==(snakey+1))||((snakey==11)&&(apley==0))))
		{
			return 1;
		}
		break;
		case 2://влево
		if((snakey == apley)&&((aplex==(snakex-1))||((snakex==0)&&(aplex==15))))
		{
			return 1;
		}
		break;
		case 3://вправо
		if((snakey == apley)&&((aplex==(snakex+1))||((snakex==15)&&(aplex==0))))
		{
			return 1;
		}
		break;		
	}
	return 0;	
}
byte IsInGame;
void gameover()
{
	setpos(0,0);
	for(int i =0;i<504;i++)
	{
		input(Gov[i]);
	}
	draw_result(5,20,dlina);
	for(int i =0;i<5;i++)
	{
		shortbeep();
	}
	IsInGame=0;
	eeprom_write_score(dlina);
	
}
void checksnakepos()
{
	uint8_t snakex=snake[0]>>4,snakey=snake[0]&0x0f,aplex=aplemaincord>>4,apley=aplemaincord&0x0f;
	if(IsThisEatable(snakex,snakey,aplex,apley))
	{
		apleIsEated=1;
		dlina++;
		shortbeep();
	}
	else
	{
		for(int i=1;i<dlina-1;i++)//чекаем не ест ли змейка сама себя
		{	//не считаем последний элемент
			if(IsThisEatable(snakex,snakey,snake[i]>>4,snake[i]&0x0f))
			{
				gameover();
			}
		}
	}

}
byte control(uint8_t CurrentVect)
{
	/*
	0-вверх
	1-вниз
	2-влево
	3-вправо
	*/
	uint8_t buff = PIND;
	if((!(buff & (1<<UP_BUT)))&&(CurrentVect!=1))
	vect=0;
	else if((!(buff & (1<<DOWN_BUT)))&&(CurrentVect!=0))
	vect=1;
	else if((!(PINB & (1<<LEFT_BUT)))&&(CurrentVect!=3))
	vect=2;
	else if((!(buff & (1<<RIGHT_BUT)))&&(CurrentVect!=2))
	vect=3;
	else if(!(buff & (1<<SELECT2_BUT)))
	vect=5;
	else {return 0;}
	while(!(PIND & (1<<SELECT2_BUT)))
		_delay_ms(10);
	return 1;
}
void in_game()
{
	srand(keygame);
	clearpole();
	snake[0]=(7<<4)|(5);//старшая часть байта - координата по x, младшая - по y
	snake[1]=(7<<4)|(6);
	//pole[1][1]=0xff;
	/*
	draw_snake_to_pole();
	drawpole();
	draw_gran();*/
	IsInGame=1;
	while(IsInGame)
	{

		checksnakepos();
		clearpole();
		if(apleIsEated)
		{
			
			while(1)
			{
				uint8_t aplecord0 =(rand()&0xff);
				uint8_t aplecord = (((aplecord0>>4)%16)<<4)|((aplecord0&0x0f)%12);
				byte ItIsOK=1;//всё в порядке
				for(int i = 0;i<dlina; i++)
				{
					if(snake[i]==aplecord)
					ItIsOK=0;//если совпало то не всё впорядке
				}
				if(ItIsOK)
				{
					aplemaincord = aplecord;
					break;
				}
			}
			apleIsEated=0;
		}
		//по выходу из цикла получаем итоговые координаты яблока
		draw_aple_to_pole();
		snake_step();
		draw_snake_to_pole();
		drawpole();
		draw_gran();
		draw_result(4,65,dlina);
		int8_t mn=1;
		switch(slozh)
		{
			case 1:mn = 3; break;
			case 2:mn = 2; break;
			case 3:mn = 4; break;
		}
		uint8_t CurrentVect = vect; 
		for(int i=0;i<25*mn;i++)
		{
			control(CurrentVect);
			if(vect==5)
				goto exit;
			_delay_ms(3);
		}
		
		
	}
	exit:
	score = eeprom_read_score();
	clear();
	clearpole();
	dlina=2;
	vect=0;
}
void draw_slozh()
{
	setpos(4,61);
	for(int i =0;i<4;i++)
	{
		input(num[slozh][i]);
	}
	setpos(0,0);
}
int snakeStart(void)
{/*
	LCDlibInit();
	init_displ();*/
	_delay_ms(10);
	clear();/*
	//char dima[] = "dima nubas 1\n";
	for(int i =0; i<10;i++)
	{
		dima[11]='0'+i;
		lcd_stream_write(dima);
		shortbeep();
		_delay_ms(250);
	}
	lcd_stream_write("Test complete");
	_delay_ms(1000);*/
	clear();
	setpos(0,0);
	draw_logo();
	uint8_t punkt=1;
	uint8_t key=0;
	score = eeprom_read_score();
	while (1)
	{
		draw_slozh();
		draw_line(20,3,26,start,punkt&0x01);
		draw_line(20,4,40,sl,punkt&0x02);
		draw_line(20,5,29,scorel,0);
		draw_result(5,50,score);
		key++;
		if((!(PIND&(1<<SELECT1_BUT)))&&(punkt==1))
		{
			keygame = key;
			//timer_stop();
			
			draw_line(20,3,26,start,0);
			beep();
			clear();
			in_game();
		}
		else if((!(PIND&(1<<UP_BUT)))&&(punkt!=1))
			punkt=punkt>>1;
		else if((!(PIND&(1<<DOWN_BUT)))&&(punkt!=2))
			punkt=punkt<<1;
		else if((!(PIND&(1<<SELECT1_BUT)))&&(punkt==2))
		{
			slozh=(slozh+1)%3;
			while(!(PIND&(1<<SELECT1_BUT)));
			
		}
		if(!(PIND&(1<<SELECT2_BUT)))
			return 0;
	}
}

#endif /* SNAKE_H_ */